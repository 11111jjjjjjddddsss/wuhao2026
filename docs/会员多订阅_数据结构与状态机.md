# 会员多订阅：冻结/解冻 — 最终版（状态机 + 裁决 + 字段 + 用例 + 冒烟）

目标：**同一时刻只允许一个生效档位（最高档优先），低档冻结不叠加、不双扣。** 前端可用（本地演示不乱扣/不串档），后端上线后「后端为唯一真相」无缝替换。

---

## 一、口径总则

- **单一生效档**：effective_tier = 当前所有订阅中「最高档且 active」的那一个。
- **低档冻结**：低档在高档 active 期间必须 paused；冻结期间**不扣天数**；高档到期后自动恢复**最高 paused** 为 active。
- **禁止降档购买**：已生效更高档时，低档购买入口置灰 + 同日一次 toast；**后端也必须校验拒绝**（不能只靠前端）。
- **前端角色**：仅展示与演示；上线后以服务端 entitlement 为准。前端可保留兼容但提供**一键切换到后端返回**的开关。

---

## 二、数据结构（前端 localStorage 与后端表字段对齐）

### 1. subscriptions 单条结构

| 字段 | 类型 | 说明 |
|------|------|------|
| user_id | string | 用户唯一标识 |
| tier | string | 档位：free \| plus \| pro \| expert |
| start_at | int64 (ms) | 订阅开始时间 |
| end_at | int64 (ms) | 订阅结束时间（active 时到期日；paused 时为理论到期，实际以 remaining_seconds 为准） |
| status | string | **active \| paused \| expired** |
| pause_at | int64 (ms) 可选 | 进入暂停的时间 |
| remaining_seconds | int 可选 | **仅在进入 paused 时计算一次**；paused 期间不递减；解冻时用于重算 end_at |
| order_id | string | 订单号，**幂等键**（同一 order_id 只允许写一次订阅变更） |
| created_at | int64 (ms) 可选 | 记录创建时间 |

### 2. 档位顺序（tier_order，全工程只改此处）

```
free < plus < pro < expert
(0)    (1)    (2)    (3)
```

任何新增档位只在此处扩展；裁决、扣减、展示均据此比较。

---

## 三、状态机规则（必须落地）

每次查询权益或写入订阅后执行裁决，规则：

**a) active 且 end_at <= now ⇒ expired**  
将本条置为 expired，不再参与裁决。

**b) 存在多条 status=active ⇒ 仅最高档保留 active，其余强制转 paused**  
对每条「非最高档」的 active：置为 paused，写入 `pause_at = now`、`remaining_seconds = max(0, (end_at - now) / 1000)`。**remaining_seconds 只在进入 paused 时计算一次；paused 期间不递减。**

**c) 当前最高 active 到期 ⇒ 从 paused 中选最高档恢复为 active**  
用该条 `remaining_seconds` 推算新 end_at：`end_at = now + remaining_seconds * 1000`；置 `resume_at = now`（可选），清空或置 0 `remaining_seconds`。

**冻结口径**：remaining_seconds 只在进入 paused 时计算一次；paused 期间不扣天数、不递减。

---

## 四、裁决规则（entitlement 计算）

- **输入**：user_id，该 user 下所有 status ∈ { active, paused } 且未过期的订阅。
- **步骤**：按上述 (a)(b)(c) 先做状态机，再：在 status=active 中取 **tier 最高** 的一条 → effective_tier；其余低于该档的为 paused_list（仅展示）。
- **输出**：effective_tier、effective_end_at、paused_list（tier + remaining_days 等，仅展示，不参与扣减与配额）。

**铁律**：任意时刻只有一条 active（且为最高档）；一次请求的扣减/配额**只**记在 effective_tier 上，**严禁双档同时扣、同时发额**。

---

## 五、购买规则（前端 + 后端必须同时做）

### 1. 禁止降档购买

- **条件**：requested_tier < effective_tier（按 tier_order 比较）。
- **后端**：拒绝，返回 `error=no_downgrade`。
- **前端**：按钮置灰文案「已开通更高档位 / 当前权益已包含」；**点灰按钮** toast「已开通更高档位，无需重复购买」（同日一次）。

### 2. 升档购买

- **条件**：requested_tier > effective_tier。
- **逻辑**：  
  1) 新订阅写入 status=active，start_at=now，end_at=now+购买时长。  
  2) 原 effective_tier 及更低档全部转 paused，写入 pause_at、remaining_seconds。  
  3) UI 立即显示新档位与到期时间；toast「已升级，立即生效」。

### 3. 同档续费

- **条件**：requested_tier == effective_tier。
- **逻辑**：end_at += 购买时长（或按订单规则叠加）；不新增一条 active。

### 4. 幂等（重复点击/重复回调）

- **键**：order_id / client_msg_id。同一订单只允许写**一次**订阅变更；重复请求直接返回成功且不重复生效、不重复扣减。

---

## 六、额度/扣减（与订阅裁决绑定）

- 所有额度（对话/图片）**只按 effective_tier** 计算与扣减；冻结档不产生额度、不扣减。
- 日额度清零：后端定时任务为准；前端仅显示后端返回的剩余值（mock 阶段可本地模拟，**须留开关**切后端）。
- 不允许「两个档位额度叠加」「双档同时扣」。

---

## 七、展示规则（极简文案冻结）

- **会员中心必须展示**：  
  - 当前生效档位：X（以最高档为准）  
  - 到期：YYYY-MM-DD 或 剩余 N 天  
  - 已冻结（可选）：如「已冻结：Plus（剩余10天）」
- **失败兜底文案（统一一条）**：「权益状态暂未更新，请稍后重试。」
- **禁止**对用户展示「余额不足/系统异常/内部错误码」等；统一用上述兜底文案。

---

## 八、迁移兼容

- **旧版单档数据**迁移为 subscriptions 的一条：  
  若存在 legacy tier/exp 且 exp > now ⇒ 写入一条 subscription(status=active)，以便后续冻结/升档正确运行。字段含 tier、start_at、end_at、order_id（如 legacy_1）、created_at 等。

---

## 九、4 条用例日志（打印 entitlement 结果）

以下为切换时刻的 **entitlement 输出**，用于对账与验收（日志中应打印 effective_tier / effective_end_at / paused_list）。

### 用例 1：Free → Plus

**前置**：无订阅或仅 free。  
**操作**：购买 Plus，订单生效。

**输出示例**：
```
entitlement: effective_tier=plus effective_end_at=<now+30天> paused_list=[]
```

---

### 用例 2：Plus 剩 10 天 → 升 Pro（Plus 冻结 10 天）

**前置**：Plus active，end_at = now+10天。  
**操作**：购买 Pro，订单生效。

**输出示例**：
```
entitlement: effective_tier=pro effective_end_at=<now+30天> paused_list=[{tier:plus,remaining_days:10}]
```

---

### 用例 3：Pro 到期 → 自动恢复 Plus 剩 10 天

**前置**：Pro active 已到期；Plus paused，remaining_seconds=10*86400。  
**操作**：下一次查询权益或定时裁决。

**输出示例**：
```
entitlement: effective_tier=plus effective_end_at=<now+10天> paused_list=[]
```

---

### 用例 4：严禁双档扣/发（同一请求只按 effective_tier）

**验证**：同一 request_id 只出现一条扣减/发额记录，且 tier 与 effective_tier 一致。

**输出示例**：
```
request_id=xxx effective_tier=pro deduct_chat=1 deduct_img=0
（无第二条 deduct，且无 plus 的 deduct）
```

---

## 十、冒烟验证（录屏/日志）

| 项 | 预期 |
|----|------|
| 升档立即生效、低档冻结不扣天数 | Pro 生效后 Plus 显示「已冻结（剩余10天）」；过 1 天再查 Plus 仍剩 10 天 |
| 到期自动解冻回退 | Pro 到期后自动恢复 Plus，剩余天数正确 |
| 降档购买入口置灰 + 后端拒绝 | 已 Pro 时 Plus 按钮置灰，点击 toast「已开通更高档位…」；后端 POST 返回 error=no_downgrade |
| 重复回调不重复生效/不重复扣减 | 同一 order_id 再次回调不新增订阅、不重复扣额 |

---

## 十一、后端接口约定（便于前端一键切换）

- **GET /api/entitlement?user_id=xxx**  
  返回：`{ effective_tier, effective_end_at, paused_list, chat_remaining, img_remaining }`（额度可由后端返回，前端仅展示）。
- **POST /api/subscription/apply**  
  Body：`{ user_id, order_id, tier, duration_days }`。  
  后端先算 effective_tier，若 tier < effective_tier 则返回 `{ error: 'no_downgrade' }`；否则按升档/同档续费规则写库，幂等按 order_id。

---

## 十二、小结

| 项 | 说明 |
|----|------|
| 表结构 | user_id, tier, start_at, end_at, status(active/paused/expired), pause_at, remaining_seconds, order_id, created_at |
| 状态机 | (a) active 且 end_at<=now→expired (b) 多 active→仅最高档 active 其余 paused (c) 最高 active 到期→解冻最高 paused 用 remaining_seconds 重算 end_at |
| 裁决 | effective_tier = 最高档 active；额度/扣减仅此一档 |
| 购买 | 禁止降档（前端置灰+toast，后端 no_downgrade）；升档立即生效、低档冻结；同档续费延 end_at；order_id 幂等 |
| 展示 | 当前档位、到期、已冻结（可选）；失败统一「权益状态暂未更新，请稍后重试」 |
| 迁移 | 旧版 tier/exp→一条 subscription(active) |

---

## 十三、冒烟结论（录屏/日志）

验证后填写：

| 项 | 结论 |
|----|------|
| 升档立即生效、低档冻结不扣天数 | [ ] 通过：Pro 生效后 Plus 显示「已冻结（剩余10天）」；过 1 天再查 Plus 仍剩 10 天 |
| 到期自动解冻回退 | [ ] 通过：Pro 到期后自动恢复 Plus，剩余天数正确 |
| 降档购买入口置灰 + 后端拒绝 | [ ] 通过：已 Pro 时 Plus 按钮置灰，点击 toast「已开通更高档位…」；POST /api/subscription/apply 返回 error=no_downgrade |
| 重复回调不重复生效/不重复扣减 | [ ] 通过：同一 order_id 再次请求返回 200 idempotent，不新增订阅 |

前端每次 computeEntitlement 会打印 `[ENT] entitlement: {...}`，可用于 4 条用例日志核对。
