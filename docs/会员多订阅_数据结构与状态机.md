# 会员多订阅：冻结/解冻 — 表结构 / 状态机 / 裁决规则

目标：**最高档立即生效，低档冻结且不计时；高档结束自动恢复低档继续生效**。严禁权益叠加、严禁双扣。后端为唯一真相。

---

## 一、数据结构

### 1. subscription 表（单条订阅记录）

| 字段 | 类型 | 说明 |
|------|------|------|
| user_id | string | 用户唯一标识 |
| tier | string | 档位：free | plus | pro | expert |
| start_at | int64 (ms) | 订阅开始时间 |
| end_at | int64 (ms) | 订阅结束时间（未暂停时：到期日；暂停时可为“理论到期”或存 remaining 即可） |
| status | string | active \| paused \| expired |
| pause_at | int64 (ms) 可选 | 进入暂停的时间 |
| resume_at | int64 (ms) 可选 | 恢复计时的时间（解冻时写） |
| remaining_seconds | int 可选 | 冻结时写入：剩余秒数；解冻时用其重算 end_at |
| order_id | string | 订单号，去重/对账 |

说明：
- **active**：当前在计时的档位（仅允许“最高档”一条为 active，其余更低档为 paused）。
- **paused**：被更高档覆盖而冻结；**不减少 remaining_seconds / 不消耗天数**。
- **expired**：已到期或已取消，不再参与裁决。

### 2. 档位顺序（用于“最高档”裁决）

```
free < plus < pro < expert
(0)    (1)    (2)    (3)
```

---

## 二、状态机与裁决规则（entitlement 计算）

### 1. 每次查询权益时执行（后端为唯一真相）

**输入**：user_id  
**数据**：该 user 下所有 `status ∈ { active, paused }` 且 `end_at > now`（或用 remaining_seconds 判断未耗尽）的订阅。

**步骤**：

1. **选当前生效档位**  
   在 `status = active` 的订阅中，取 **tier 最高** 的一条；若无则无付费生效档位（effective_tier = free）。

2. **冻结所有更低档**  
   对所有 tier 严格低于“当前生效档位”的订阅：若 `status != paused`，则置为 `paused`，并写入 `pause_at = now`、`remaining_seconds = max(0, (end_at - now) / 1000)`（剩余秒数冻结保存）。**paused 期间不扣减 remaining_seconds，不推进 end_at。**

3. **高档到期/取消后的解冻**  
   若当前生效的那条 active 订阅已过期（`end_at <= now` 或 remaining 耗尽）：  
   - 将其置为 `expired`。  
   - 在其余 **paused** 且未过期的订阅中，取 **tier 最高** 的一条，置为 `active`，并：  
     - `resume_at = now`；  
     - `end_at = now + remaining_seconds * 1000`（用冻结时存的剩余秒数恢复计时）；  
     - 清空 `remaining_seconds` 或置为 0（已用于重算 end_at）。  
   - 若没有可恢复的 paused，则 effective_tier = free。

4. **输出（entitlement）**  
   - `effective_tier`：当前生效档位（用于扣减、配额、路由）。  
   - `effective_end_at`：当前生效档位的到期时间。  
   - `paused_list`：被冻结的订阅列表（tier + remaining_seconds 或 remaining_days），仅展示用，不参与扣减与配额。

**铁律**：  
- 任意时刻**只有一条** subscription 的 status = active（且为最高档）。  
- 一次请求的扣减/配额**只**记在 effective_tier 上；**严禁双档同时扣减、同时发额度。**

### 2. 购买/回调生效时的约束

- **禁止降档**：若当前 `effective_tier`（由上述步骤算出）**高于**待生效订单的 tier，则：  
  - **拒绝**创建订单或拒绝回调生效；  
  - 返回 `error=no_downgrade`。  
- **升档**：允许。新订单生效后插入/更新 subscription，status=active，然后**重新跑一遍上述裁决**，使新档为 active、所有更低档置为 paused 并写入 pause_at / remaining_seconds。

---

## 三、前端展示（与裁决结果一致）

- **主展示**：只展示「当前生效档位（最高档）+ 到期时间/剩余天数」；扣减与配额仅依 effective_tier。
- **可选**：若存在被冻结订阅，可展示「已冻结：XX档（剩余X天）」；仅展示，不参与扣减与配额。

---

## 四、验收用例与日志（4 条）

以下 4 条用例的**切换时刻** entitlement 输出（effective_tier / effective_end_at / paused_list），用于对账与验收。

---

### 用例 1：Free → Plus（Plus 立即生效；Free 若存在订阅则 paused 且不计时）

**前置**：无订阅或仅有 free（无付费订阅记录）。

**操作**：用户购买 Plus，订单回调生效。

**后端**：插入一条 subscription：tier=plus, status=active, start_at=now, end_at=now+30天, order_id=xxx。

**裁决输出（切换时刻）**：

```
effective_tier: plus
effective_end_at: <now + 30天>
paused_list: []
```

说明：无低档订阅，无冻结。Plus 立即生效。

---

### 用例 2：Plus 剩 10 天时升 Pro（Pro 立即生效；Plus 变 paused 且仍剩 10 天）

**前置**：有一条 Plus，status=active，end_at = now + 10天。

**操作**：用户购买 Pro，订单回调生效。

**后端**：  
1. 插入 Pro：tier=pro, status=active, start_at=now, end_at=now+30天。  
2. 裁决：当前 active 最高档 = pro；Plus 的 tier < pro，置为 paused，pause_at=now，remaining_seconds=(end_at_plus - now)=10*86400。

**裁决输出（切换时刻）**：

```
effective_tier: pro
effective_end_at: <now + 30天>
paused_list: [ { tier: plus, remaining_days: 10 } ]
```

说明：Pro 生效；Plus 冻结且 remaining 仍为 10 天，不扣减。

---

### 用例 3：Pro 到期（Plus 自动恢复，仍剩 10 天）

**前置**：Pro 为 active，end_at 已到；Plus 为 paused，remaining_seconds 对应 10 天。

**操作**：时间推进到 Pro 的 end_at 之后，用户下一次查询权益或定时任务跑裁决。

**后端**：  
1. Pro：end_at <= now → 置为 expired。  
2. 在 paused 中取最高档 = Plus；置为 active，resume_at=now，end_at=now+remaining_seconds*1000（即再给 10 天）。  
3. remaining_seconds 已用于重算 end_at，不再单独扣减。

**裁决输出（切换时刻）**：

```
effective_tier: plus
effective_end_at: <now + 10天>
paused_list: []
```

说明：Plus 恢复后仍剩 10 天（未少一天）；仅一条 active，无双扣。

---

### 用例 4：任意时刻不会出现“两个档位都扣/都发额度”

**验证点**：  
- 裁决结果中 effective_tier 唯一；  
- 扣减/配额接口仅依据本次查询得到的 effective_tier 做**单档**扣减与发额；  
- 日志中同一 request_id 只出现一条“扣减/发额”记录，且 tier 与 effective_tier 一致。

**示例日志（请求扣减时）**：

```
request_id=xxx effective_tier=pro deduct_chat=1 deduct_img=0
（无第二条 deduct 记录，且无 plus 的 deduct）
```

---

## 五、后端购买限制（必须）

- 创建订单或支付回调生效前：先按当前数据跑一遍 **entitlement**，得到当前 `effective_tier`。  
- 若 `tier_level(待购档位) <= tier_level(effective_tier)` 且待购档位 ≠ effective_tier：  
  - **拒绝**订单创建或回调生效；  
  - 返回 `error=no_downgrade`。  
- 前端置灰仅为体验；**后端必须做上述校验**，禁止降档生效。

---

## 六、前端本地实现（与后端规则一致）

- 前端使用 `membership_subscriptions`（localStorage）存储订阅数组，结构同上；`computeEntitlement()` 按同一裁决规则计算 effective_tier、冻结/解冻并持久化。
- 升档时追加新订阅并重算；高档到期后下次 `getMembership()`/`getCurrentTier()` 时自动解冻最高 paused。
- 购买限制：前端已禁止降档置灰并 toas「已开通更高档位，无需重复购买」；后端接口必须校验并返回 `error=no_downgrade`。

---

## 七、小结

| 项 | 说明 |
|----|------|
| 表结构 | user_id, tier, start_at, end_at, status(active/paused/expired), pause_at, resume_at, remaining_seconds, order_id |
| 裁决规则 | 取最高 tier 且 status=active 为生效档；低档统一 paused；paused 不扣天数；高档到期后解冻最高 paused，用 remaining_seconds 重算 end_at |
| 购买限制 | 后端校验 effective_tier，拒绝降档，返回 error=no_downgrade |
| 扣减/额度 | 仅依 effective_tier 单档扣减、单档发额，严禁双档同时 |
