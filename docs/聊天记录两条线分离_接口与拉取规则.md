# 聊天记录两条线分离 + 拉取规则

目标：**UI 展示层的裁剪/分页/本地不持久化，不得影响 A/B 链路；换设备/卸载重装不丢 A/B，不断层。** 后端为 A/B 唯一真相。

---

## 一、存储位置（后端真相）

| 层 | 存储 | 绑定 | 写入时机 |
|----|------|------|----------|
| **A 层** | DB，累计对话轮次（可能 >24） | user_id + session_id | **仅** assistant done=true / onComplete 后写入一轮 (user, assistant) |
| **B 层** | DB，累计摘要 | user_id + session_id | B 覆盖写**成功**后才允许清 A；失败不清 A |

- interrupted / stop / timeout：**不写 A、不扣费、不影响 A/B**。
- 严禁从 DOM 回读拼 A/B 上下文；A/B 只来自后端或本地与后端同步后的状态。

---

## 二、接口定义

### 1. GET session snapshot（拉取会话快照）

**用途**：App 启动 / 切会话时，用 user_id + session_id 从后端拉取 B + 最近 N 轮 A（N=24 仅用于 UI 回显）。

**请求**：
```
GET /api/session/snapshot?user_id={userId}&session_id={sessionId}
```

**响应**（200）：
```json
{
  "b_summary": "字符串，当前会话 B 层累计摘要，无则空串",
  "a_rounds": [
    { "user": "用户消息", "assistant": "助手回复" },
    ...
  ]
}
```
- `a_rounds`：**最近 N 轮**（建议 N=24），按时间正序；用于 UI 回显。后端 A 可存超过 24 轮，但本接口只返回最近 N 轮供展示。
- 无该 session 时：`b_summary=""`，`a_rounds=[]`。

---

### 2. POST append A（追加一轮 A）

**用途**：仅 onComplete 时调用，向后端追加一轮完整 (user, assistant)。

**请求**：
```
POST /api/session/append-a
Content-Type: application/json

{
  "user_id": "string",
  "session_id": "string",
  "user_message": "string",
  "assistant_message": "string"
}
```

**响应**：
- 200：成功写入；body 可返回当前 A 轮数等（可选）。
- 4xx/5xx：写入失败；客户端不清 A、不重试写 B 依赖本次写入。

**规则**：仅在 assistant **onComplete(done=true)** 后调用；interrupted/stop/timeout 不调用。

---

### 3. POST update B（写入 B 并清 A）

**用途**：B 层提取成功后，覆盖写 B；**仅当 B 写入成功**后，后端才清空该 session 的 A（或标记已消费）。

**请求**：
```
POST /api/session/update-b
Content-Type: application/json

{
  "user_id": "string",
  "session_id": "string",
  "b_summary": "string"
}
```

**响应**：
- 200：B 写入成功；后端原子清空该 session 的 A（或等价语义）。
- 4xx/5xx：写入失败；**后端不清 A**；客户端不清本地 A。

**规则**：B 覆盖写成功后才允许清 A；失败不清 A。

---

## 三、拉取与恢复（客户端）

- **App 启动 / 切会话**：  
  1. 使用当前 `user_id`、`session_id` 调用 **GET session snapshot**。  
  2. 用返回的 `b_summary` 恢复 B（写入本地或直接用于主对话）。  
  3. 用返回的 `a_rounds`（最近 N 轮，N=24）**仅做 UI 回显**（渲染为历史气泡），**不**用 DOM 反推 A/B 上下文；主对话的 A/B 上下文仍以后端为准（或拉取后写入本地 AB 状态，由 ABLayerManager 等读本地）。

- **UI 展示**：  
  - 只渲染最近 30 轮（≤60 条 message）为**纯展示裁剪**（如 RENDER_WINDOW、hardTrimMessages）；**不得**用裁剪后的 DOM 去更新或推导 A/B；A/B 数据只来自后端拉取或 onComplete/updateB 的写入。

- **触发规则不变**：  
  - B 提取：A≥24 后，每轮 onComplete 尝试；输入为「当前累计 A（可能>24）」；**B 成功写入后才清 A**。  
  - interrupted/stop/timeout：不写 A、不扣费、不影响 A/B。

---

## 四、验收

| 项 | 要求 |
|----|------|
| 换设备登录 | 能恢复 B + 最近 24 轮 A；不中断、不串 session |
| UI 清空/裁剪 | 不影响后端 A/B；下一轮仍能正确提取 B（因 A/B 来自后端或同步后的本地状态，不来自 DOM） |

---

## 五、换设备用例日志（2 条）

### 用例 1：换设备后恢复 B + 最近 24 轮 A，不串 session

**前置**：用户在设备 A 上 session_id=S1，已有 B 摘要、A 共 30 轮（后端全量存）。

**操作**：用户在设备 B 上登录同一 user_id，切到 session S1（或默认进入 S1）。

**客户端**：调用 `GET /api/session/snapshot?user_id=U1&session_id=S1`。

**后端响应**：
```json
{
  "b_summary": "用户曾咨询作物病害…（当前会话 B 摘要）",
  "a_rounds": [ { "user": "...", "assistant": "..." }, ... ]
}
```
`a_rounds` 长度为 24（最近 24 轮）。

**客户端**：用 `b_summary` 恢复 B 展示与注入；用 `a_rounds` 渲染 24 条历史消息（仅 UI）；后续主对话/B 提取仍用后端（或已同步的本地）A/B，不读 DOM。

**日志要点**：
- request: GET snapshot user_id=U1 session_id=S1
- response: b_summary 长度=xxx, a_rounds.length=24
- 结果：B 恢复，UI 显示 24 轮历史；不串 session、不断层。

---

### 用例 2：UI 清空/裁剪后，下一轮仍正确提取 B

**前置**：当前 session 后端 A 已有 25 轮，B 已有一版摘要；前端 UI 因 RENDER_WINDOW/hardTrimMessages 只保留最近 30 条 DOM。

**操作**：用户再发一条消息，assistant onComplete。

**客户端**：  
1. 调用 **POST append-a** 写入本轮 (user, assistant)。  
2. 后端 A 变为 26 轮；触发 B 提取（输入为当前累计 A，可能>24）。  
3. B 提取成功，调用 **POST update-b**；后端写入 B 并清 A。

**要点**：A/B 的「当前累计 A」「B 摘要」均来自后端（或已与后端同步的本地状态），**不**从 DOM 读取；UI 裁剪/清空不影响本轮 B 提取与下一轮上下文。

**日志要点**：
- POST append-a session_id=S1 → 200
- B 提取成功 → POST update-b → 200
- 结果：下一轮主对话仍拿到正确 B + 空 A（或新累积 A）；UI 曾裁剪/清空不产生影响。

---

## 六、小结

| 项 | 说明 |
|----|------|
| 存储 | A/B 存 DB，按 user_id + session_id；A 仅 onComplete 写；B 成功写后才清 A |
| GET snapshot | 拉取 B + 最近 N 轮 A（N=24 供 UI）；不改变后端 A/B |
| POST append-a | 仅 onComplete 追加一轮 A |
| POST update-b | B 覆盖写；成功则后端清 A |
| UI | 最近 30 轮/≤60 条为展示裁剪，不得影响 A/B 数据源 |
| 换设备 | 拉取 B + 最近 24 轮 A 恢复；不串 session、不断层 |
