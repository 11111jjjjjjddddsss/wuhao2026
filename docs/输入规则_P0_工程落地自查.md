# 输入规则（最终版·冻结）工程落地自查

## 一、输入规则逐条 → 对应代码位置表

| 规则条目 | 要求 | 对应代码位置（文件 + 函数/逻辑） | 状态 |
|----------|------|----------------------------------|------|
| **1️⃣ 四层输入权重与标记** | | | |
| 当前用户输入 | 必须标记为【当前优先处理的问题】 | `QwenClient.kt`：`callApi` 内构建 user content，`mainText = "【当前优先处理的问题】\n$userMessage`（约 145–146 行） | ✅ 已落地 |
| A 层历史对话 | 必须标记为【A层历史对话（中等参考性）】 | `ABLayerManager.kt`：`getARoundsTextForMainDialogue()` 返回 `"【A层历史对话（中等参考性）】\n" + buildDialogueText(snapshot)`（约 47–54 行）；`QwenClient.kt`：`callApi` 内 `aText = ABLayerManager.getARoundsTextForMainDialogue()`，拼入 systemContent，且 `ensureSystemRole` 后通过 `buildSystemContentWithLayers(base, aText, bSum)` 重写 system（约 113–116、168–174、318–324 行） | ✅ 已落地 |
| B 层累计摘要 | 必须标记为【B层累计摘要（低参考性）】 | `QwenClient.kt`：`callApi` 内 `systemContent` 拼接 `"【B层累计摘要（低参考性）】\n$bSum"`，以及 `buildSystemContentWithLayers` 中同样拼接（约 117–119、170、320–322 行） | ✅ 已落地 |
| 联网搜索结果 | 必须标记为【工具信息（极低参考性）】；仅本轮有效、不写 A/B、不参与后续轮 | `QwenClient.kt`：`callApi` 内 `toolInfo` 拼入 user【工具信息（极低参考性）】（`QwenClient.kt` buildMainDialogueMessages）；`toolInfo` 仅在本轮 user 消息中传入，不写入 A/B（A 仅 `onRoundComplete` 写入，B 仅 B 提取成功写入）；`gpt-demo.html`：`pendingSendByStreamId` 仅当前轮使用，下一轮不携带（约 2456–2476、2726–2730 行） | ✅ 已落地 |
| **2️⃣ 输入形态约束** | | | |
| 仅允许：纯文字 或 文字+图片 | 非法输入不触发模型调用 | **前端**：`gpt-demo.html` 的 `sendMessage()` 中 `if (!text) return;`、`if (hasImages && !text) return;`（约 2393–2398 行）；**Android**：`MainActivity.kt` 的 `sendMessage` 中 `if (hasImages && !hasText) return@runOnUiThread`（约 258–266 行）；**QwenClient**：`if (imgCount > 0 && userMessage.isBlank()) throw Exception("有图片时必须带文字描述")`（约 179 行） | ✅ 已落地 |
| 禁止：只有图片、无文字 | 同上 | 同上三层拦截 | ✅ 已落地 |
| **3️⃣ 图片输入规则** | | | |
| 单次最多 4 张 | 工程硬限制 | **前端**：`MainActivity.kt` 的 `uploadImages` 中 `if (imageDataList.size > 4)` 弹窗并 return（约 132–135 行）；**QwenClient.kt**：`if (imgCount > 4) throw Exception("图片数量超过限制...")`（约 178 行）；**ImageUploader.kt**：`MAX_IMAGE_COUNT = 4`，`uploadImages` 中 `size > MAX_IMAGE_COUNT` 返回 null（约 26、274–276 行） | ✅ 已落地 |
| 每次图片输入必须同时有文字 | 同 2️⃣ | 同 2️⃣ | ✅ 已落地 |
| 最长边 1536px | 预处理真实生效 | `ImageUploader.kt`：`MAX_LONG_EDGE = 1536`，`compressImage()` 内按长边缩放至 ≤1536（最终版·冻结） | ✅ 已落地 |
| 单张 ≤1MB | 预处理真实生效 | `ImageUploader.kt`：`MAX_SIZE_BYTES = 1024*1024`，质量 80–85，仍超则按比例缩放直至 ≤1MB（最终版·冻结） | ✅ 已落地 |
| JPEG 质量 80–85 | 预处理真实生效 | `ImageUploader.kt`：`JPEG_QUALITY_HIGH = 85`、`JPEG_QUALITY_LOW = 80`，先 85 后 80（最终版·冻结） | ✅ 已落地 |
| 输入推荐 JPEG/PNG；其他格式能解码则转 JPEG，解码失败提示用户转 JPEG/PNG | 解码后统一输出 JPEG；失败时用户提示 | `ImageUploader.kt`：解码后统一 `compressToJpeg`；`MainActivity.kt`：解码/压缩失败时 `"该图片格式暂不支持，请转为 JPEG/PNG 后重试"` | ✅ 已落地 |
| **4️⃣ 图片与扣费/轮次** | | | |
| 图片与文字一并作为本轮输入 | 同一次请求 | `QwenClient.kt`：同一 user 消息中 content 先图后文（约 129–157 行） | ✅ 已落地 |
| 图片重要程度交给模型判断 | 工程不做语义判断 | 无对图片做“重要性”过滤的逻辑，仅做预处理与投喂 | ✅ 已落地 |
| 有图 → 本轮图片扣 1 次（1–4 张皆 1 次） | 仅 onComplete 扣 | `gpt-demo.html`：`pendingDeduct[streamId] = (imageUrls.length > 0 ? 1 : 0)`（约 2454 行）；`onCompleteReceived` 内 `imgUploadCount = pendingDeduct[streamId]`，`incrementUsage(1, imgUploadCount)`（约 2664–2667 行） | ✅ 已落地 |
| 中断/失败/stop/timeout 不扣 | 不扣且清理 pending | `gpt-demo.html`：`onStreamInterrupted`、watchdog 路径仅 `delete pendingDeduct[streamId]`，不调用 `incrementUsage`（约 2521、2541、2571、2746 行） | ✅ 已落地 |
| **5️⃣ 空态处理** | | | |
| 无 B/A/联网时直接基于当前用户输入处理 | 不提示“信息不足”、不暴露系统状态 | `QwenClient.kt`：无 B 则不拼 B，无 A 则 `getARoundsTextForMainDialogue()` 返回 ""，无 toolInfo 则不拼工具信息；全空时 system 仅 anchor，user 仅【当前优先处理的问题】；代码中无“信息不足”或暴露 B/A/搜索状态的文案 | ✅ 已落地 |

---

## 二、图片预处理实现说明（含关键参数）

| 项目 | 实现位置 | 关键参数与逻辑 |
|------|----------|----------------|
| **入口** | `MainActivity.kt` → `uploadSingleImage()`（约 322–366 行） | 对每张图：Base64 解码 → `ImageUploader.compressImage(imageBytes)` → 上传压缩后 bytes → 回传 URL |
| **压缩与缩放** | `ImageUploader.kt` → `compressImage(imageBytes)` | 1）EXIF 方向矫正；2）长边缩放到 **MAX_LONG_EDGE = 1536**；3）转 JPEG：质量 **80–85**，若 size > **MAX_SIZE_BYTES = 1MB** 则用 80 并迭代缩放直至 ≤1MB（最终版·冻结） |
| **输出格式** | `ImageUploader.kt` → `compressToJpeg(bitmap, quality)` | 统一 `Bitmap.CompressFormat.JPEG`，质量 80 或 85 |
| **送入模型** | `MainActivity.kt` → 上传成功回调得到 `url` → `sendToModel(..., imageUrlList)` → `QwenClient.callApi(..., imageUrlList, ...)` | 请求体中 user content 为「预处理后图片 URL」+ 文本；URL 对应 OSS 上已压缩的 JPEG 文件 |

**HEIC/WEBP**：解码依赖 `BitmapFactory.decodeStream`（WEBP 普遍支持；HEIC 需 Android 10+）。解码成功后统一经 `compressToJpeg` 输出 JPEG，满足「HEIC/WEBP 转码为 JPEG」。

---

## 三、四层输入在主对话请求中的实际形态示例

**场景**：当前有 A 层 2 轮、B 层有摘要、本轮用户输入为「今天天气怎样」、本轮回传了联网搜索 toolInfo。

- **system（一条）**  
  内容为锚点 + A 层（若有）+ B 层（若有），例如：
  ```
  <system_anchor 全文>

  【A层历史对话（中等参考性）】
  user: 昨天你说了啥
  assistant: 昨天我们聊了…

  user: 再总结下
  assistant: 总结如下…

  【B层累计摘要（低参考性）】
  <B 摘要正文>
  ```

- **user（一条）**  
  content 为数组：先若干条 `type: "image_url"`（若有图），再一条 `type: "text"`，例如：
  ```
  【当前优先处理的问题】
  今天天气怎样

  [极低参考性·工具信息]
  【联网搜索结果（Bocha）】
  1) 某站 - https://...
     摘要：…
  ```

**无 A/B/toolInfo 时**：system 仅锚点（或空），user 仅【当前优先处理的问题】+ 可选图片，无“信息不足”等提示。

---

## 四、冒烟验证结论（至少 4 条）

| 冒烟项 | 预期 | 验证方式与结论 |
|--------|------|----------------|
| **大图压缩** | 长边 ≤1536px、单张 ≤1MB、JPEG 80–85 | `ImageUploader.compressImage()`：长边 1536、质量 80–85，超 1MB 则降质并迭代缩放直至 ≤1MB（最终版·冻结）；日志输出压缩后尺寸与字节数。 |
| **HEIC/WEBP 转 JPEG** | 解码后统一以 JPEG 输出 | 解码用 `BitmapFactory.decodeStream`（系统支持 WEBP/HEIC 时可行），输出仅经 `compressToJpeg()`；上传与模型侧均为 JPEG。**结论**：工程上已统一输出 JPEG，HEIC 在 API 29+ 可解码；若设备不支持 HEIC 解码会返回 null，前端会收到上传失败。 |
| **4 张图只扣 1 次** | 有图则 `pendingDeduct[streamId]=1`，onComplete 时 `incrementUsage(1, 1)` 一次 | `gpt-demo.html`：`pendingDeduct[streamId] = (imageUrls.length > 0 ? 1 : 0)`；`onCompleteReceived` 中按 `pendingDeduct[streamId]` 扣一次并 `deducted[streamId]=true` 防重。**结论**：1–4 张图均为“本轮图片扣 1 次”，逻辑已落地。 |
| **弱网/中断不扣费** | 未 onComplete 不调用 `incrementUsage`，且清理 pending | `onStreamInterrupted`、watchdog 超时、用户 stop 等路径仅清理 `pendingDeduct`/`pendingRequest`，不调用 `incrementUsage`；扣费仅在 `onCompleteReceived` 内执行。**结论**：中断/失败/stop/timeout 不扣费已落地。 |

---

## 五、联网搜索相关自查（必须）

| 项 | 要求 | 实现位置与结论 |
|----|------|----------------|
| 成功时 | 结果进入主对话模型（【工具信息（极低参考性）】）且 UI 灰块展示 | 模型：`toolInfo` 经 `QwenClient.callApi(..., toolInfo)` 拼入 user 文本（见上第三节）。UI：`onSearchResult(streamId, resultText)` → `renderToolResult(streamId, 'bocha', trimmed)`（`gpt-demo.html` 约 2726–2729 行）。**结论**：满足。 |
| 失败/空结果 | 不阻断主对话、不写 A/B、UI 静默 | 空/失败不写 A/B（A 仅 onRoundComplete 写，B 仅 B 提取写）；`onSearchResult` 空时 `trimmed` 为空不渲染灰块，仍可 `doSendWithSearchResult(streamId, '')` 正常发主请求；失败时 MainActivity 仅对 network/timeout/rate_limit 等提示，其余静默。**结论**：满足。 |
| 模型看到 vs 用户看到 | 模型：结构化搜索结果文本；用户：灰块+可点击 URL | 模型：BochaClient 返回的 `resultText` 同源传入 `toolInfo`。用户：灰块内通过 `linkifyToolResultText()` 将 http(s) URL 转为 `<a target="_blank">`，`renderToolResult()` 使用 `innerHTML` 渲染（`gpt-demo.html`）。**结论**：数据同源；灰块内 URL 可点击已落地。 |

---

## 六、纠错说明（A 层口径）

- **错误表述**：「A 层最多 24 轮」——错误。24 仅为**触发 B 提取的阈值**（A≥24 时每轮尝试 B 提取），A 可累计**超过 24 轮**，且**仅当 B 层提取成功写入后才清空 A**。
- **主对话注入 A**：必须为「当前累计 A 全文」，**不得** `takeLast(24)` / `subList` / `limit 24`。
- **代码核对**：`ABLayerManager.getARoundsTextForMainDialogue()` 使用 `aRoundsBySession[sessionId]?.toList()` 取**全文快照**，无任何截断（无 takeLast/subList/limit）。`tryExtractAndUpdateB(sessionId, snapshot)` 的 `snapshot` 为当时 A 的**完整列表**，B 提取使用完整 A。

---

## 七、真实请求样例（含四层标记）

以下为一次主对话请求的 system / user 文本形态（可直接用于对账/联调）。

**system 内容示例**（锚点 + A 全文 + B 摘要）：
```
<system_anchor.txt 全文>

【A层历史对话（中等参考性）】
user: 昨天我们聊了啥
assistant: 昨天聊了作物病害…

user: 再总结下要点
assistant: 要点是…

【B层累计摘要（低参考性）】
用户曾咨询作物病害，已给出要点总结；当前会话在延续该主题。
```

**user content 文本部分示例**（当前问题 + 本轮工具信息）：
```
【当前优先处理的问题】
今天北京天气怎么样

[极低参考性·工具信息]
【联网搜索结果（Bocha）】
1) 北京天气 - https://example.com/weather
   摘要：今日晴，15-25℃。
```

---

## 八、联网搜索三种样例（模型投喂 / 灰块 / 静默）

| 场景 | 模型是否收到 toolInfo | 灰块是否展示 | 用户侧表现 |
|------|------------------------|--------------|------------|
| **成功且有结果** | 是：`toolInfo` 为 Bocha 返回的「标题 - URL - 摘要」文本，拼入 user【工具信息（极低参考性）】 | 是：`onSearchResult(streamId, resultText)` → `renderToolResult(streamId, 'bocha', trimmed)`，灰块内 URL 可点击 | 正常回复 + 灰块 |
| **空结果** | 否：`resultText` 为空，`doSendWithSearchResult(streamId, '')`，主对话照常发，无 toolInfo | 否：`trimmed` 为空不调用 `renderToolResult` | 主对话照常；UI 无“暂无结果”等，静默 |
| **失败**（如 auth/quota/server） | 否：搜索失败不回调成功，前端超时或未收到结果，`doSendWithSearchResult(streamId, '')` 发主对话 | 否 | 仅 network/timeout/rate_limit 可出现“可重试”短提示（MainActivity）；其余静默 + 日志，不出现“余额不足/鉴权失败”等 |

---

## 九、冒烟 6 条（验证结论）

| # | 冒烟项 | 预期 | 对应代码/结论 |
|---|--------|------|----------------|
| 1 | **文字成功** | 仅文字发送 → onComplete → 扣对话 1 次、图片 0 次 | `pendingDeduct[streamId]=0`；`onCompleteReceived` 内 `incrementUsage(1, imgUploadCount)`。✅ |
| 2 | **1 图成功** | 1 张图+文字 → onComplete → 扣对话 1、图片 1 次 | `pendingDeduct[streamId]=1`；同上。✅ |
| 3 | **4 图成功** | 4 张图+文字 → onComplete → 扣对话 1、图片 1 次（仍 1 次） | `pendingDeduct[streamId] = (imageUrls.length > 0 ? 1 : 0)`。✅ |
| 4 | **中断不扣** | onStreamInterrupted / stop / watchdog → 不扣、只清 pending | 仅 `delete pendingDeduct/pendingRequest`，不调用 `incrementUsage`。✅ |
| 5 | **并发不串单** | 多 streamId；重试用 pendingRequest 取回 text+imageUrls，newStreamId 再挂 pending | `pendingRequest[streamId]`、`pendingDeduct[streamId]`、`deducted[streamId]` 均以 streamId 为 key；重试从 `pendingRequest[oldStreamId]` 取 data，生成 newStreamId 后 `pendingRequest[newStreamId]=...`。✅ |
| 6 | **搜索成功/失败行为** | 成功→模型投喂+灰块；空/失败→主对话照发、静默（仅 network/timeout/rate_limit 可提示） | 见第八节；BochaClient 空返回 ""、失败走 onFailure；MainActivity 仅对 network/timeout/rate_limit 调 onStreamInterrupted。✅ |

---

## 十、收口结论（四条必答）

| 问题 | 结论 | 对应函数/位置 |
|------|------|----------------|
| ① A 是否被截断？ | **否** | `ABLayerManager.getARoundsTextForMainDialogue()`：`aRoundsBySession[sessionId]?.toList()` 全文，无 takeLast(24)/subList/limit |
| ② B 提取是否用完整 A？ | **是** | `ABLayerManager.tryExtractAndUpdateB(sessionId, snapshot)`：snapshot 为当时 A 的完整列表 `list.map { it }`，无截断 |
| ③ 灰块 URL 可点？ | **是** | `gpt-demo.html`：`linkifyToolResultText()` 将 http(s) URL 转 `<a>`，`renderToolResult()` 用 `innerHTML` 渲染灰块 |
| ④ 解码失败提示已加？ | **是** | `MainActivity.kt`：`uploadSingleImage()` 内 compressResult==null 或 catch 时，`onImageUploadStatus(..., 'fail', null, requestId, '该图片格式暂不支持，请转为JPG/PNG后重试')`；不触发模型、不扣费、不卡发送态 |

---

**说明**：本自查表与《输入规则（最终版·冻结）》及代码一一对应；冒烟项中“大图压缩”“解码失败提示转 JPEG/PNG”建议真机/模拟器端到端验证。
